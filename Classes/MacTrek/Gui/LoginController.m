//
//  LoginController.m
//  MacTrek
//
//  Created by Aqua on 27/05/2006.
//  Copyright 2006 Luky Soft. See Licence.txt for licence details.
//

#import "LoginController.h"


@implementation LoginController

bool makeNewPassword = NO;
bool clockRunning = NO;

// get initial stuff
- (id) init {
    self = [super init];
    if (self != nil) {        
        loginManager = [[LoginManager alloc] init];   
		multiThreaded = NO;
    }
    return self;
}

- (void) awakeFromNib {
    
	// set the user name
    [playerName setStringValue:NSUserName()];
    
	// subscribe to interesting events
	
	// first internal events
	// login window finished typing
	[[NSNotificationCenter defaultCenter] addObserver:self
											 selector:@selector(loginDidEndEditing:)
												 name:@"NSControlTextDidEndEditingNotification"
											   object:playerName];
    // password window finished typing
	[[NSNotificationCenter defaultCenter] addObserver:self
											 selector:@selector(passwordDidEndEditing:)
												 name:@"NSControlTextDidEndEditingNotification"
											   object:playerPassword];
    // verify did end typinh
    [[NSNotificationCenter defaultCenter] addObserver:self
											 selector:@selector(passwordVerifyDidEndEditing:)
												 name:@"NSControlTextDidEndEditingNotification"
											   object:playerPasswordVerify];
    
	// then external
    // login manager events
    [notificationCenter addObserver:self selector:@selector(invalidServer:)	
							   name:@"LM_LOGIN_INVALID_SERVER" object:nil useLocks:NO useMainRunLoop:YES];
    [notificationCenter addObserver:self selector:@selector(getPassword:)	
							   name:@"LM_LOGIN_GET_PASSWORD" object:nil useLocks:NO useMainRunLoop:YES];
    [notificationCenter addObserver:self selector:@selector(loginComplete:)	
                               name:@"LM_LOGIN_COMPLETE" object:nil useLocks:NO useMainRunLoop:YES];
    [notificationCenter addObserver:self selector:@selector(makePassword:)	
                               name:@"LM_LOGIN_MAKE_PASSWORD" object:nil useLocks:NO useMainRunLoop:YES];
    [notificationCenter addObserver:self selector:@selector(badLogin:)	
                               name:@"LM_LOGIN_BAD_PASSWORD" object:nil useLocks:NO useMainRunLoop:YES];
    
}

- (void) setMultiThreaded:(bool)multi {
    multiThreaded = multi;
}

// events generated by menu
- (void) reset {
    [loginManager reset];
    [playerPassword setStringValue:@""];
    [playerPasswordVerify setStringValue:@""];
}

- (void) enablePlayerName {
    [outfitButton setEnabled:NO];
    
    [loginInstruction setStringValue:@"Enter your name.  Use the name 'guest' to remain anonymous."];
    [playerName setEnabled:YES];
}

- (void) disablePlayerName {
    
    [loginInstruction setStringValue:@"Please select a server before playing."];
    [playerName setEnabled:NO];
    [outfitButton setEnabled:NO];
}

// handling of the events generated by the login manager
- (void) invalidServer:(id)sender {
    [loginInstruction setStringValue:@"Sorry, this client is incompatible with Paradise servers."];
    // select a new server
    [notificationCenter postNotificationName:@"LC_INVALID_SERVER"];
    [playerName setEnabled:NO];
    [outfitButton setEnabled:NO];
}

- (void) getPassword:(id)sender {
    // name is known get the password
    [loginInstruction setStringValue:@"Name known, enter your password:"];
    [playerPassword setEnabled:YES];
    [playerPassword selectText:self];
    makeNewPassword = NO;
    [outfitButton setEnabled:NO];
}

- (void) loginComplete:(id)sender {
    LLLog(@"LoginController.loginComplete reached");
    [loginInstruction setStringValue:@"Welcome!"];
    [notificationCenter postNotificationName:@"LC_LOGIN_COMPLETE"];
    [outfitButton setEnabled:YES];
}

- (void) makePassword:(id)sender {
    // name is unknown get the password
    [loginInstruction setStringValue:@"Name unknown, you need to make a password:"];
    [playerPassword setEnabled:YES];
    [playerPassword selectText:self];
    makeNewPassword = YES;
    [outfitButton setEnabled:NO];
}

- (void) badLogin:(id)sender {
    [loginInstruction setStringValue:@"Bad password!"];
    [playerPassword setEnabled:NO];
    [playerName setEnabled:YES];
    [playerName selectText:self];
    [outfitButton setEnabled:NO];
}

// handling of input events
- (void)passwordDidEndEditing:(NSNotification *)aNotification {
	LLLog(@"LoginController.passwordDidEndEditing %@", [aNotification name]);
    
    if (makeNewPassword) {
        [loginInstruction setStringValue:@"Enter it again to make sure you typed it right."];
        [playerPasswordVerify setEnabled:YES];
        [playerPasswordVerify setHidden:NO];
        [playerPasswordVerify selectText:self];        
        // wait until the verify is complete
    } else { // go for login
        [loginManager setPassword: [playerPassword stringValue]];
    }
    [playerPassword setEnabled:NO];
    
    // the login manager will send a packet for the pass, we must read the reply
    // unless it is done in a seperate thread
    if (!multiThreaded) {
        [notificationCenter postNotificationName:@"COMM_READ_FROM_SERVER"];
    }
}

- (void)loginDidEndEditing:(NSNotification *)aNotification {
	LLLog(@"LoginController.loginDidEndEditing %@", [aNotification name]);
    
    // and login
    [loginManager setName: [playerName stringValue]];
    [playerName setEnabled:NO];
    
    // the login manager will send a packet for the name, we must read the reply
    // unless it is done in a seperate thread
    if (!multiThreaded) {
        // read until a SP_LOGIN_OK or NOK comes
        while ([loginManager state] == LOGIN_GETNAME) {
            [notificationCenter postNotificationName:@"COMM_READ_FROM_SERVER"]; 
        }
        // done, we moved to the next stage (new name, or known name)
        if ([[[playerName stringValue] uppercaseString] isEqualToString:@"GUEST"]) {
            // guest login, we will have moved to password request
            // but this is not needed accepted, needs no password
            if ([loginManager state] == LOGIN_GETPASS) {
                [self passwordDidEndEditing:nil];
            }            
        }
    }
}

- (void)passwordVerifyDidEndEditing:(NSNotification *)aNotification {
	LLLog(@"LoginController.passwordVerifyDidEndEditing %@", [aNotification name]);
    
    // verify complete
    if ([[playerPassword stringValue] isEqualToString:[playerPasswordVerify stringValue]]) {
        // hide it again
        [playerPasswordVerify setHidden:YES];
        // we know the password is the same, so try to login
        [loginManager setPassword: [playerPassword stringValue]];
        
        // the login manager will send a packet for the pass, we must read the reply
        // unless it is done in a seperate thread
        if (!multiThreaded) {
            [notificationCenter postNotificationName:@"COMM_READ_FROM_SERVER"];
        }
    } else {
        [loginInstruction setStringValue:@"Passwords do not match! try again"];
        [playerPassword setEnabled:YES];
        [playerPassword selectText:self];
    }
}

- (void) stopClock {
    clockRunning = NO;    
}

- (void) tickTak {
    
    if (clockRunning == NO) {
        // clock stopped
        return;
    }
    
    // decrease 1 sec
    [loginClock setIntValue:[loginClock intValue] - 1];
    if ([loginClock intValue] <= 0) {
        [self stopClock];
        [notificationCenter postNotificationName:@"LC_LOGIN_CLOCK_EXPIRED"];        
    } else {
        // wait 1 sec for another tick
        [self performSelector: @selector(tickTak) withObject: self afterDelay: 1];
    }
}

- (void) startClock {
    if (clockRunning) {
        LLLog(@"LoginController.startClock clock already running");
        return;        
    }
    
    // when the clock starts we have 99 seconds
    clockRunning = YES;
    [loginClock setIntValue:100];
    [self tickTak];   
}
@end
